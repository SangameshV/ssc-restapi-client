/*
 * Fortify Software Security Center API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1:18.20
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.fortify.ssc.restclient.model;

import java.util.Objects;
import com.fortify.ssc.restclient.model.PluginConfiguration;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * plugin meta data holds attributes of the plugins installed in the application.
 */
@ApiModel(description = "plugin meta data holds attributes of the plugins installed in the application.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-07-09T13:54:27.094-07:00")
public class PluginMetaData {
  @SerializedName("apiVersion")
  private String apiVersion = null;

  @SerializedName("dataVersion")
  private Integer dataVersion = null;

  @SerializedName("description")
  private String description = null;

  @SerializedName("engineType")
  private String engineType = null;

  @SerializedName("id")
  private Long id = null;

  @SerializedName("lastUsedOfKind")
  private Boolean lastUsedOfKind = null;

  @SerializedName("pluginConfiguration")
  private List<PluginConfiguration> pluginConfiguration = new ArrayList<PluginConfiguration>();

  @SerializedName("pluginId")
  private String pluginId = null;

  @SerializedName("pluginName")
  private String pluginName = null;

  /**
   * State of the plugin instance
   */
  @JsonAdapter(PluginStateEnum.Adapter.class)
  public enum PluginStateEnum {
    STOPPED("STOPPED"),
    
    STARTING("STARTING"),
    
    STARTED("STARTED"),
    
    STOPPING("STOPPING"),
    
    FAILED_TO_START("FAILED_TO_START"),
    
    FAILED_TO_STOP("FAILED_TO_STOP"),
    
    UNKNOWN("UNKNOWN");

    private String value;

    PluginStateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PluginStateEnum fromValue(String text) {
      for (PluginStateEnum b : PluginStateEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<PluginStateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PluginStateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PluginStateEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return PluginStateEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("pluginState")
  private PluginStateEnum pluginState = null;

  /**
   * Denotes functionality of the plugin instance, such as scan parsing, bugtracker integration.
   */
  @JsonAdapter(PluginTypeEnum.Adapter.class)
  public enum PluginTypeEnum {
    SCAN_PARSER("SCAN_PARSER"),
    
    BUG_TRACKER("BUG_TRACKER"),
    
    LEGACY_BUG_TRACKER("LEGACY_BUG_TRACKER");

    private String value;

    PluginTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PluginTypeEnum fromValue(String text) {
      for (PluginTypeEnum b : PluginTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<PluginTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PluginTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PluginTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return PluginTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("pluginType")
  private PluginTypeEnum pluginType = null;

  @SerializedName("pluginVersion")
  private String pluginVersion = null;

  @SerializedName("supportedEngineVersions")
  private String supportedEngineVersions = null;

  @SerializedName("systemInstalled")
  private Boolean systemInstalled = null;

  @SerializedName("vendorName")
  private String vendorName = null;

  @SerializedName("vendorUrl")
  private String vendorUrl = null;

  public PluginMetaData apiVersion(String apiVersion) {
    this.apiVersion = apiVersion;
    return this;
  }

   /**
   * Version string of the SSC plugin api used to develop the plugin
   * @return apiVersion
  **/
  @ApiModelProperty(required = true, value = "Version string of the SSC plugin api used to develop the plugin")
  public String getApiVersion() {
    return apiVersion;
  }

  public void setApiVersion(String apiVersion) {
    this.apiVersion = apiVersion;
  }

  public PluginMetaData dataVersion(Integer dataVersion) {
    this.dataVersion = dataVersion;
    return this;
  }

   /**
   * An integer used to tag the set of issue attributes provided by this plugin.
   * @return dataVersion
  **/
  @ApiModelProperty(required = true, value = "An integer used to tag the set of issue attributes provided by this plugin.")
  public Integer getDataVersion() {
    return dataVersion;
  }

  public void setDataVersion(Integer dataVersion) {
    this.dataVersion = dataVersion;
  }

   /**
   * Plugin description
   * @return description
  **/
  @ApiModelProperty(value = "Plugin description")
  public String getDescription() {
    return description;
  }

   /**
   * Name of the scan engine supported by the plugin. Value is defined for parser plugins only
   * @return engineType
  **/
  @ApiModelProperty(value = "Name of the scan engine supported by the plugin. Value is defined for parser plugins only")
  public String getEngineType() {
    return engineType;
  }

   /**
   * Plugin unique identifier
   * @return id
  **/
  @ApiModelProperty(value = "Plugin unique identifier")
  public Long getId() {
    return id;
  }

  public PluginMetaData lastUsedOfKind(Boolean lastUsedOfKind) {
    this.lastUsedOfKind = lastUsedOfKind;
    return this;
  }

   /**
   * Tracks whether this plugin instance was the most recently used of its kind
   * @return lastUsedOfKind
  **/
  @ApiModelProperty(example = "false", required = true, value = "Tracks whether this plugin instance was the most recently used of its kind")
  public Boolean isLastUsedOfKind() {
    return lastUsedOfKind;
  }

  public void setLastUsedOfKind(Boolean lastUsedOfKind) {
    this.lastUsedOfKind = lastUsedOfKind;
  }

  public PluginMetaData pluginConfiguration(List<PluginConfiguration> pluginConfiguration) {
    this.pluginConfiguration = pluginConfiguration;
    return this;
  }

  public PluginMetaData addPluginConfigurationItem(PluginConfiguration pluginConfigurationItem) {
    this.pluginConfiguration.add(pluginConfigurationItem);
    return this;
  }

   /**
   * Additional configuration properties used by the plugin
   * @return pluginConfiguration
  **/
  @ApiModelProperty(required = true, value = "Additional configuration properties used by the plugin")
  public List<PluginConfiguration> getPluginConfiguration() {
    return pluginConfiguration;
  }

  public void setPluginConfiguration(List<PluginConfiguration> pluginConfiguration) {
    this.pluginConfiguration = pluginConfiguration;
  }

  public PluginMetaData pluginId(String pluginId) {
    this.pluginId = pluginId;
    return this;
  }

   /**
   * Identifier of the plugin, usually a fully-qualified classname. Non-unique when multiple versions of same plugin exist
   * @return pluginId
  **/
  @ApiModelProperty(required = true, value = "Identifier of the plugin, usually a fully-qualified classname. Non-unique when multiple versions of same plugin exist")
  public String getPluginId() {
    return pluginId;
  }

  public void setPluginId(String pluginId) {
    this.pluginId = pluginId;
  }

  public PluginMetaData pluginName(String pluginName) {
    this.pluginName = pluginName;
    return this;
  }

   /**
   * A string name for the plugin
   * @return pluginName
  **/
  @ApiModelProperty(required = true, value = "A string name for the plugin")
  public String getPluginName() {
    return pluginName;
  }

  public void setPluginName(String pluginName) {
    this.pluginName = pluginName;
  }

  public PluginMetaData pluginState(PluginStateEnum pluginState) {
    this.pluginState = pluginState;
    return this;
  }

   /**
   * State of the plugin instance
   * @return pluginState
  **/
  @ApiModelProperty(required = true, value = "State of the plugin instance")
  public PluginStateEnum getPluginState() {
    return pluginState;
  }

  public void setPluginState(PluginStateEnum pluginState) {
    this.pluginState = pluginState;
  }

  public PluginMetaData pluginType(PluginTypeEnum pluginType) {
    this.pluginType = pluginType;
    return this;
  }

   /**
   * Denotes functionality of the plugin instance, such as scan parsing, bugtracker integration.
   * @return pluginType
  **/
  @ApiModelProperty(required = true, value = "Denotes functionality of the plugin instance, such as scan parsing, bugtracker integration.")
  public PluginTypeEnum getPluginType() {
    return pluginType;
  }

  public void setPluginType(PluginTypeEnum pluginType) {
    this.pluginType = pluginType;
  }

  public PluginMetaData pluginVersion(String pluginVersion) {
    this.pluginVersion = pluginVersion;
    return this;
  }

   /**
   * A version string of the implementation code of the plugin
   * @return pluginVersion
  **/
  @ApiModelProperty(required = true, value = "A version string of the implementation code of the plugin")
  public String getPluginVersion() {
    return pluginVersion;
  }

  public void setPluginVersion(String pluginVersion) {
    this.pluginVersion = pluginVersion;
  }

   /**
   * Versions of the scan engine results supported by the plugin. Value is defined for parser plugins only
   * @return supportedEngineVersions
  **/
  @ApiModelProperty(value = "Versions of the scan engine results supported by the plugin. Value is defined for parser plugins only")
  public String getSupportedEngineVersions() {
    return supportedEngineVersions;
  }

  public PluginMetaData systemInstalled(Boolean systemInstalled) {
    this.systemInstalled = systemInstalled;
    return this;
  }

   /**
   * whether the plugin instance was installed by adding the jar to a special system folder
   * @return systemInstalled
  **/
  @ApiModelProperty(example = "false", required = true, value = "whether the plugin instance was installed by adding the jar to a special system folder")
  public Boolean isSystemInstalled() {
    return systemInstalled;
  }

  public void setSystemInstalled(Boolean systemInstalled) {
    this.systemInstalled = systemInstalled;
  }

   /**
   * Name of the company / organization that developed the plugin
   * @return vendorName
  **/
  @ApiModelProperty(value = "Name of the company / organization that developed the plugin")
  public String getVendorName() {
    return vendorName;
  }

   /**
   * Plugin vendor&#39;s web site URL
   * @return vendorUrl
  **/
  @ApiModelProperty(value = "Plugin vendor's web site URL")
  public String getVendorUrl() {
    return vendorUrl;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PluginMetaData pluginMetaData = (PluginMetaData) o;
    return Objects.equals(this.apiVersion, pluginMetaData.apiVersion) &&
        Objects.equals(this.dataVersion, pluginMetaData.dataVersion) &&
        Objects.equals(this.description, pluginMetaData.description) &&
        Objects.equals(this.engineType, pluginMetaData.engineType) &&
        Objects.equals(this.id, pluginMetaData.id) &&
        Objects.equals(this.lastUsedOfKind, pluginMetaData.lastUsedOfKind) &&
        Objects.equals(this.pluginConfiguration, pluginMetaData.pluginConfiguration) &&
        Objects.equals(this.pluginId, pluginMetaData.pluginId) &&
        Objects.equals(this.pluginName, pluginMetaData.pluginName) &&
        Objects.equals(this.pluginState, pluginMetaData.pluginState) &&
        Objects.equals(this.pluginType, pluginMetaData.pluginType) &&
        Objects.equals(this.pluginVersion, pluginMetaData.pluginVersion) &&
        Objects.equals(this.supportedEngineVersions, pluginMetaData.supportedEngineVersions) &&
        Objects.equals(this.systemInstalled, pluginMetaData.systemInstalled) &&
        Objects.equals(this.vendorName, pluginMetaData.vendorName) &&
        Objects.equals(this.vendorUrl, pluginMetaData.vendorUrl);
  }

  @Override
  public int hashCode() {
    return Objects.hash(apiVersion, dataVersion, description, engineType, id, lastUsedOfKind, pluginConfiguration, pluginId, pluginName, pluginState, pluginType, pluginVersion, supportedEngineVersions, systemInstalled, vendorName, vendorUrl);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PluginMetaData {\n");
    
    sb.append("    apiVersion: ").append(toIndentedString(apiVersion)).append("\n");
    sb.append("    dataVersion: ").append(toIndentedString(dataVersion)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    engineType: ").append(toIndentedString(engineType)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    lastUsedOfKind: ").append(toIndentedString(lastUsedOfKind)).append("\n");
    sb.append("    pluginConfiguration: ").append(toIndentedString(pluginConfiguration)).append("\n");
    sb.append("    pluginId: ").append(toIndentedString(pluginId)).append("\n");
    sb.append("    pluginName: ").append(toIndentedString(pluginName)).append("\n");
    sb.append("    pluginState: ").append(toIndentedString(pluginState)).append("\n");
    sb.append("    pluginType: ").append(toIndentedString(pluginType)).append("\n");
    sb.append("    pluginVersion: ").append(toIndentedString(pluginVersion)).append("\n");
    sb.append("    supportedEngineVersions: ").append(toIndentedString(supportedEngineVersions)).append("\n");
    sb.append("    systemInstalled: ").append(toIndentedString(systemInstalled)).append("\n");
    sb.append("    vendorName: ").append(toIndentedString(vendorName)).append("\n");
    sb.append("    vendorUrl: ").append(toIndentedString(vendorUrl)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

